/**
 * Custom migration script - why?
 * Well migration scripts aren't so complex, and we haven't found a simple enough library
 * to deserve a new dependency. We like this setup because we can customize it easily
 * and it's pretty easy to understand.
 *
 * This migration system handles both custom TypeScript migrations and
 * SQL migrations generated by Drizzle.
 */

import { basename } from 'node:path'

import { getDBClient } from './getDBClient'

import type { PoolClient } from 'pg'

export type Migration = {
  name: string
  up?: (client: PoolClient) => Promise<void>
  /** per-migration timeout in ms, overrides defaultTimeout */
  timeout?: number
}

/** default timeout for migrations (5 seconds) */
const DEFAULT_MIGRATION_TIMEOUT = 5_000

export type MigrateOptions = {
  connectionString: string
  migrationsGlob: Record<string, () => Promise<unknown>>
  createDatabases?: string[]
  onMigrationComplete?: () => Promise<void>
  gitSha?: string
  cvrDb?: string
  changeDb?: string
  /** default timeout for all migrations in ms (default: 5000) */
  defaultTimeout?: number
}

// check if we're running in AWS Lambda or other serverless environment
const isServerless = !!(
  process.env.AWS_LAMBDA_FUNCTION_NAME ||
  process.env.AWS_LAMBDA_RUNTIME_API ||
  process.env.LAMBDA_RUNTIME_DIR ||
  process.env.IS_SERVERLESS
)

async function withTimeout<T>(promise: Promise<T>, ms: number, name: string): Promise<T> {
  let timeoutId: ReturnType<typeof setTimeout>
  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error(`migration "${name}" timed out after ${ms}ms`))
    }, ms)
  })
  try {
    return await Promise.race([promise, timeoutPromise])
  } finally {
    clearTimeout(timeoutId!)
  }
}

export async function migrate(options: MigrateOptions) {
  const {
    connectionString,
    migrationsGlob,
    createDatabases = [],
    onMigrationComplete,
    gitSha,
    cvrDb,
    changeDb,
    defaultTimeout = DEFAULT_MIGRATION_TIMEOUT,
  } = options

  const client = await getDBClient({ connectionString })

  const hasDB = async (name: string) => {
    const result = !!(
      await client.query(`
        SELECT 1 FROM pg_database WHERE datname = '${name}'
      `)
    ).rows.length

    return result
  }

  // create zero databases if specified
  if (cvrDb || changeDb) {
    if (!cvrDb) {
      throw new Error(`Missing cvrDb`)
    }

    const zeroDBNames = [basename(cvrDb || ''), basename(changeDb || '')].filter(Boolean)

    for (const name of zeroDBNames) {
      if (!(await hasDB(name))) {
        await client.query(`CREATE DATABASE ${name};`)
      }
    }
  }

  // create additional databases if specified
  for (const dbUrl of createDatabases) {
    const name = basename(dbUrl)
    if (!(await hasDB(name))) {
      await client.query(`CREATE DATABASE ${name};`)
    }
  }

  try {
    await client.query('BEGIN')
    // use public schema explicitly - pg_dump restores into public, and if a schema
    // matching the db user exists (e.g. startchat), unqualified names resolve there first
    await client.query(`
      CREATE TABLE IF NOT EXISTS public.migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        run_on TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `)

    const appliedMigrations = await client.query('SELECT name FROM public.migrations')
    const appliedMigrationNames = new Set(appliedMigrations.rows.map((row) => row.name))

    // get TypeScript migrations
    const tsMigrationsSorted = Object.entries(migrationsGlob)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([file, run]) => ({
        name: basename(file).replace('.ts', ''),
        run,
      }))
      .filter(({ name }) => /^[\d]+/.test(name))

    // process TypeScript migrations
    const tsMigrations: Migration[] = await Promise.all(
      tsMigrationsSorted.map(async ({ name, run }) => {
        if (appliedMigrationNames.has(name)) {
          return null
        }
        try {
          const migration = (await run()) as object
          return { ...migration, name }
        } catch (error) {
          console.error(`Failed to load TypeScript migration ${name}:`, error)
          throw error
        }
      })
    ).then((migrations) => migrations.filter(Boolean) as Migration[])

    // combine TypeScript and SQL migrations, sorted by name to ensure correct order
    const migrations = [...tsMigrations].sort((a, b) => a.name.localeCompare(b.name))

    if (!migrations.length) {
      await client.query('COMMIT')
    } else {
      for (const migration of migrations) {
        if (migration.up) {
          // use savepoints so "already exists" errors don't abort the transaction.
          // this handles cases where tables/columns exist but migration tracking
          // was lost (e.g. db restore, pglite data loss)
          const sp = `sp_${migration.name.replace(/\W/g, '_')}`
          await client.query(`SAVEPOINT ${sp}`)
          try {
            const timeout = migration.timeout ?? defaultTimeout
            await withTimeout(migration.up(client), timeout, migration.name)
            await client.query(`RELEASE SAVEPOINT ${sp}`)
          } catch (e: any) {
            await client.query(`ROLLBACK TO SAVEPOINT ${sp}`)
            // pg "duplicate" class errors: table, column, object, etc
            if (e?.code?.startsWith('42')) {
              console.info(
                `[migrate] ${migration.name}: ${e.message}, recording as applied`
              )
            } else {
              throw e
            }
          }
        }

        await client.query('INSERT INTO public.migrations (name) VALUES ($1)', [
          migration.name,
        ])
      }

      await client.query('COMMIT')
    }
  } catch (e) {
    console.error(`Migration failed, rolling back:`, e)
    await client.query('ROLLBACK')
    try {
      client.release(false)
    } catch (releaseErr) {
      console.error(`Error releasing connection after rollback:`, releaseErr)
    }
    throw e
  }

  if (onMigrationComplete) {
    await onMigrationComplete()
  }

  try {
    // don't destroy the connection forcefully - let it return to pool gracefully
    client.release(false)
  } catch (err) {
    console.error(`Error releasing connection gracefully, trying to destroy:`, err)
    try {
      client.release(true)
    } catch (destroyErr) {
      console.error(`Error destroying connection:`, destroyErr)
    }
  }

  exitProcess()
}

function exitProcess() {
  if (typeof process === 'undefined') return
  // lambda was complaining about process.exit
  if (isServerless) return
  process.exit(0)
}
